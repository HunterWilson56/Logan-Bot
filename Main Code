const Discord = require("discord.js");
const client = new Discord.Client();
const weather = require('weather-js');
const mentionHook = new Discord.WebhookClient("WEbHOOK_ID", "WEBHOOK_TOKEN");
const moment = require("moment");
const config = require("./config.json");
const settings = require("./settings.json");
const help = require("./botconfig.json");
var ffmpeg = require('FFMPEG');
const bot = new Discord.Client({disableEveryone: true});
bot.commands = new Discord.Collection();



var embed = new Discord.RichEmbed();
const randomColor = "#000000".replace(/0/g, function () { return (~~(Math.random() * 16)).toString(16); });
const DBL = require('dblapi.js');
const dbl = new DBL('', { webhookPort: 5009, webhookAuth: 'password' });
dbl.webhook.on('ready', hook => {
  console.log(`Webhook running at http://${hook.hostname}:${hook.port}${hook.path}`);
});
dbl.webhook.on('vote', vote => {
  console.log(vote);
  // Do what you need to do
});
client.on('ready', () => {
    setInterval(() => {
        dbl.postStats(client.guilds.size);
    }, 1800000);
});
//const Manager = new Discord.ShardingManager('./index.js');
//Manager.spawn(2); 
const tools = require("./eval.js");
client.on("ready", function() {
    var clientonmessage = `
------------------------------------------------------
> Logging in...
------------------------------------------------------
Logged in as ${client.user.tag}
Working on ${client.guilds.size} servers!
${client.channels.size} channels and ${client.users.size} users cached!
I am logged in and ready to roll!
LET'S GO!
------------------------------------------------------
----------Bot created by Tea Cup#3433-----------
------------------------------------------------------
-----------------Bot's commands logs------------------`

    console.log(clientonmessage);
    client.user.setGame(
        `l.help | on ${client.guilds.size} servers|Vrs;1.6.2`,
        "https://www.twitch.tv/xxwilsongamingxx"
      );
});//l.help | on ${client.guilds.size} servers|Vrs;1.6.2


function hook(channel, title, message, color, avatar) { // This function uses quite a few options. The last 2 are optional.

    // Reassign default parameters - If any are blank.
    if (!channel) return console.log('Channel not specified.');
    if (!title) return console.log('Title not specified.');
    if (!message) return console.log('Message not specified.');
    if (!color) color = 'd9a744'; // This is an optional variable. Therefore the default HEX color will be whatever you post there. Mine will be d9a744
    if (!avatar) avatar = 'https://cdn4.iconfinder.com/data/icons/technology-devices-1/500/speech-bubble-128.png' // This is also an optional variable, you can change the default to any icon.

    // We want to remove spaces from color & url, since they might have it on the sides.
    color = color.replace(/\s/g, '');
    avatar = avatar.replace(/\s/g, '');

    // This is the start of creating the webhook
    channel.fetchWebhooks() // This gets the webhooks in the channel
        .then(webhook => {

            // Fetches the webhook we will use for each hook
            let foundHook = webhook.find('name', 'Webhook'); // You can rename 'Webhook' to the name of your bot if you like, people will see if under the webhooks tab of the channel.

            // This runs if the webhook is not found.
            if (!foundHook) {
                channel.createWebhook('Webhook', 'https://cdn4.iconfinder.com/data/icons/technology-devices-1/500/speech-bubble-128.png') // Make sure this is the same thing for when you search for the webhook. The png image will be the default image seen under the channel. Change it to whatever you want.
                    .then(webhook => {
                        // Finally send the webhook
                        webhook.send('', {
                            "username": title,
                            "avatarURL": avatar,
                            "embeds": [{
                                "color": parseInt(`0x${color}`),
                                "description":message
                            }]
                        })
                            .catch(error => { // We also want to make sure if an error is found, to report it in chat.
                                console.log(error);
                                return channel.send('**Something went wrong when sending the webhook. Please check console.**');
                            })
                    })
            } else { // That webhook was only for if it couldn't find the original webhook
                foundHook.send('', { // This means you can just copy and paste the webhook & catch part.
                    "username": title,
                    "avatarURL": avatar,
                    "embeds": [{
                        "color": parseInt(`0x${color}`),
                        "description":message
                    }]
                })
                    .catch(error => { // We also want to make sure if an error is found, to report it in chat.
                        console.log(error);
                        return channel.send('**Something went wrong when sending the webhook. Please check console.**');
                    })
                }

        })

}


  client.on('guildMemberAdd', member => {
	const members = member.guild.memberCount;
	const channel = member.guild.channels.find('name', 'welcome');
	if (!channel) return;
	let role = member.guild.roles.find(`name`, "User");
	
	let Embed = new Discord.RichEmbed()
	.setTitle(`${member.displayName}, Welcome to ${member.guild.name}`)
    .setColor(randomColor)	
	.setDescription(`Welcome My Friend!`)
	.addField('Users: ', `${members}`, true)
	channel.send(Embed);
	});
	client.on('guildMemberRemove', member => {
	const channel = member.guild.channels.find('name', 'welcome');
	if (!channel) return;
	const members = member.guild.memberCount;
	let Embed = new Discord.RichEmbed()
    .setColor(randomColor)
	.setDescription(`${member.displayName}, has left the server! We have ${members} members now.`)

	channel.send(Embed);
    });
    
	client.on('guildCreate', guild => {

        guild.owner.send("Thank You for adding me  Type `l.help` in your server to see my commands! ");
        
        console.log(`The bot just joined to ${guild.name}, Owned by ${guild.owner.user.tag}`);
        });

    client.on("guildDelete", guild => {
        console.log(`The bot has been left ${guild.name}, Owned by ${guild.owner.user.tag}`);
    });

const prefix = "l.";






// Logs of the bot leaves a server




client.on("message", async message => {
    if (message.author.bot) return;
    if (message.content.indexOf("l.") !== 0) return;
    const args = message.content.slice("l.".length).trim().split(/ +/g);
    const command = args.shift().toLowerCase();
    if(command === "ping") {
        const m = await message.channel.send("Ping?");
        m.edit(`Pong! Latency is ${m.createdTimestamp - message.createdTimestamp}ms. API Latency is ${Math.round(client.ping)}ms`);
    }
});




// Turn bot off (destroy), then turn it back on

client.on("message", async message => {
  if(message.author.bot) return;
  if(message.channel.type === "dm") return;

  let prefix = "l.";
  let messageArray = message.content.split(" ");
  let cmd = messageArray[0];
  let args = messageArray.slice(1);

  if(cmd === `${prefix}kick`){

    //!kick @daeshan askin for it

    let kUser = message.guild.member(message.mentions.users.first() || message.guild.members.get(args[0]));
    if(!kUser) return message.channel.send("Can't find user!");
    let kReason = args.join(" ").slice(22);
    if(!message.member.hasPermission("ADMINISTRATOR")) return message.channel.send("No can do pal!");
    if(kUser.hasPermission("ADMINISTRATOR")) return message.channel.send("That person can't be kicked!");

    let kickEmbed = new Discord.RichEmbed()
    .setDescription("~Kick~")
    .setColor(randomColor)
    .addField("Kicked User", `${kUser} with ID ${kUser.id}`)
    .addField("Kicked By", `<@${message.author.id}> with ID ${message.author.id}`)
    .addField("Kicked In", message.channel)
    .addField("Tiime", message.createdAt)
    .addField("Reason", kReason);

    let kickChannel = message.guild.channels.find(`name`, "mod-log");
    if(!kickChannel) return message.channel.send("Can't find `mod log` channel.");

    message.guild.member(kUser).kick(kReason);
    kickChannel.send(kickEmbed);

    return;
  }

  if(cmd === `${prefix}ban`){

    let bUser = message.guild.member(message.mentions.users.first() || message.guild.members.get(args[0]));
    if(!bUser) return message.channel.send("Can't find user!");
    let bReason = args.join(" ").slice(22);
    if(!message.member.hasPermission("ADMINISTRATOR")) return message.channel.send("No can do pal!");
    if(bUser.hasPermission("ADMINISTRATOR")) return message.channel.send("That person can't be kicked!");

    let banEmbed = new Discord.RichEmbed()
    .setDescription("~Ban~")
    .setColor(randomColor)
    .addField("Banned User", `${bUser} with ID ${bUser.id}`)
    .addField("Banned By", `<@${message.author.id}> with ID ${message.author.id}`)
    .addField("Banned In", message.channel)
    .addField("Time", message.createdAt)
    .addField("Reason", bReason);

    let incidentchannel = message.guild.channels.find(`name`, "mod-log");
    if(!incidentchannel) return message.channel.send("Can't find `mod-log` channel.");

    message.guild.member(bUser).ban(bReason);
    incidentchannel.send(banEmbed);


    return;
  }

  if(cmd === `${prefix}report`){
        

    let rUser = message.guild.member(message.mentions.users.first() || message.guild.members.get(args[0]));
    if(!rUser) return message.channel.send("could not find the user!");
    let reason = args.join(" ").slice(22);
    
    let reportEmbed = new Discord.RichEmbed()
    .setDescription("reports")
    .setColor("#9B59B6")
    .addField("Reported By",`<@${message.author.id}> with ID ${message.author.id}`)
    .addField("Reason", reason)
    .addField("Reported User", `${rUser} with ID: ${rUser.id}`);

    let incidentchannel = message.guild.channels.find(`name`, "mod-log");
    if(!incidentchannel) return message.channel.send("Can't find `mod-log` channel.");

    incidentchannel.send(reportEmbed);
  }

  if(cmd === `${prefix}Commands`){

    let bicon = client.user.displayAvatarURL;
    let botembed = new Discord.RichEmbed()
    .setDescription("Commands For Logan Bot!")
    .setColor(randomColor)
    .setThumbnail(bicon)
    .addField("Main Commands",'|``l.hi``|``l.invite``|``l.info``|\n|``l.help``|``l.yt``|``l.games``|\n |``l.suggest`|``l.ping``|``l.afk``|\n |``l.web``|``l.vote``|``l.stats``|\n |``l.log``|``l.roll`` |``l.autow``|\n |``l.8ball``|``l.weather``|``l.serverinfo``|\n |``l.botinfo``|``l.userinfo``|``l.uptime``| \n|``l.softban``|``l.ownerhelp``|``l.mute``| \n |``l.botservers``|``l.report``| \n|``l.translate``| More Coming', true )
    .addField("Music",'JUST OPENED TODAY!(4/10/18) :tada: `l.play`|`l.stop`|`l.skip`|`l.pause`|`l.resume`|`l.volume`|`l.queue`| \n')
    .addField("Moderation",'l.modhelp' )
    .addField("Developer Only",'l.ownerhelp')
    .addField("Level Commands", 'Locked :lock:');

    return message.channel.send(botembed);
}



});

client.on("message", async message => {
    if(message.author.bot) return;
    if(message.channel.type === "dm") return;
  
    let prefix = "l.";
    let messageArray = message.content.split(" ");
    let cmd = messageArray[0];
    let args = messageArray.slice(1);
if(cmd === `${prefix}stats`){

    let ms = client.uptime;
    let cd = 24 * 60 * 60 * 1000; // Calc days
    let ch = 60 * 60 * 1000; // Calc hours
    let cm = 60 * 1000; // Calc minutes
    let cs = 1000; // Calc seconds
    let days = Math.floor(ms / cd);
    let dms = days * cd; // Days, in ms
    let hours = Math.floor((ms - dms) / ch);
    let hms = hours * ch; // Hours, in ms
    let minutes = Math.floor((ms - dms - hms) / cm);
    let mms = minutes * cm; // Minutes, in ms
    let seconds = Math.round((ms - dms - hms - mms) / cs);
    if (seconds === 60) {
        minutes++; // Increase by 1
        seconds = 0;
    }
    if (minutes === 60) {
        hours++; // Inc by 1
        minutes = 0;
    }
    if (hours === 24) {
        days++; // Increase by 1
        hours = 0;
    }
    let dateStrings = [];

    if (days === 1) {
        dateStrings.push('**1** day');
    } else if (days > 1) {
        dateStrings.push('**' + String(days) + '** days');
    }

    if (hours === 1) {
        dateStrings.push('**1** hour');
    } else if (hours > 1) {
        dateStrings.push('**' + String(hours) + '** hours');
    }

    if (minutes === 1) {
        dateStrings.push('**1** minute');
    } else if (minutes > 1) {
        dateStrings.push('**' + String(minutes) + '** minutes');
    }

    if (seconds === 1) {
        dateStrings.push('**1** second');
    } else if (seconds > 1) {
        dateStrings.push('**' + String(seconds) + '** seconds');
    }

    let dateString = '';
    for (let i = 0; i < dateStrings.length - 1; i++) {
        dateString += dateStrings[i];
        dateString += ', ';
    }
    if (dateStrings.length >= 2) {
        dateString = dateString.slice(0, dateString.length - 2) + dateString.slice(dateString.length - 1);
        dateString += 'and ';
    }
    dateString += dateStrings[dateStrings.length - 1];
    let bicon = client.user.displayAvatarURL;
    let statsembed = new Discord.RichEmbed()
    .setDescription("Stats")
    .setColor(randomColor)
    .setThumbnail(bicon)
    .addField("Servers",client.guilds.size)
    .addField("Users",client.users.size)
    .addField("Uptime",dateString)

    


    return message.channel.send(statsembed);
}


// This episode will be going over the hook command.
});




client.on("message", async message => {
  if (message.author.equals(client.user)) return;

  if (!message.content.startsWith(settings.botPREFIX)) return;

  //Disables commands in a private chat
  if  (message.channel.type == "dm") return console.log(`${message.author.tag} tried to use a command in DM!`);

  //Users blacklist
  if (message.author.id == "") return console.log(`[BlackList] ${message.author.tag} tried to use a command!`);

  //Channels blacklist
  if (message.channel.id == "") return;

  //Servers blacklist
  if (message.guild.id == "") return;

  var args = message.content.substring(settings.botPREFIX.length).split(" ");
  switch (args[0]) {
    case "ping":
        console.log(`${message.author.tag} used the ${settings.botPREFIX}ping command!`);
        message.reply("Pong!");
    break;

    case "botinfo":
    console.log(`${message.author.tag} used the ${settings.botPREFIX}botinfo command!`);

    message.channel.send({embed: {
        color: 3447003,
        title: "Info:",
        description: "This is the info about the bot",
        fields: [{
            name: "Created by:",
            value: "This bot created by Tea Cup#3343"
          },
          {
            name: "Made with:",
            value: "This bot made with [Discord.JS](http://discord.js.org)"
          },
          {
            name: "Contact me:",
            value: "_**Tea Cup#3343**_"
          },
          {
            name: "Social Media",
            value: " [Steam]() "
          },
          {
            name: "Invite the bot here",
            value: ":robot: **l.invite**"
          }
        ],
        timestamp: new Date(),
        footer: {
          icon_url: client.user.avatarURL,
          text: "© Logan 2018"
        }
      }
    });

    case "userinfo":
    console.log(`${message.author.tag} used the ${settings.botPREFIX}userinfo command!`);

    let user = message.mentions.users.first();
    if (!user) {
        return message.reply('You must mention someone!');
    }
    const mentioneduser = message.mentions.users.first();
    const joineddiscord = (mentioneduser.createdAt.getDate() + 1) + '-' + (mentioneduser.createdAt.getMonth() + 1) + '-' + mentioneduser.createdAt.getFullYear() + ' | ' + mentioneduser.createdAt.getHours() + ':' + mentioneduser.createdAt.getMinutes() + ':' + mentioneduser.createdAt.getSeconds();
    let game;
    if (user.presence.game === null) {
        game = 'Not currently Playing.';
    } else {
        game = user.presence.game.name;
    }
    let messag;
    if (user.lastMessage === null) {
        messag = 'He didnt sent a message.';
    } else {
        messag = user.lastMessage;
    }
    let status;
    if (user.presence.status === 'online') {
        status = ':green_heart:';
    } else if (user.presence.status === 'dnd') {
        status = ':heart:';
    } else if (user.presence.status === 'idle') {
        status = ':yellow_heart:';
    } else if (user.presence.status === 'offline') {
        status = ':black_heart:';
    }
  // Let afk;
  // if (user.presence.data.afk === true) {
  //   afk = "✅"
  // } else {
  //   afk = "❌"
  // }
    let stat;
    if (user.presence.status === 'offline') {
        stat = 0x000000;
    } else if (user.presence.status === 'online') {
        stat = 0x00AA4C;
    } else if (user.presence.status === 'dnd') {
        stat = 0x9C0000;
    } else if (user.presence.status === 'idle') {
        stat = 0xF7C035;
    }
  message.channel.send({embed: {
    color: 3447003,
    author: {
      name: `Got some info about ${user.username}`,
      icon_url: user.displayAvatarURL
    },
    fields: [{
        name: '**UserInfo:**',
        value: `**Username:** ${user.tag}\n**Joined Discord:** ${joineddiscord}\n**Last message:** ${messag}\n**Playing:** ${game}\n**Status:** ${status}\n**Bot?** ${user.bot}`
      },
      {
        name: 'DiscordInfo:',
        value: `**Discriminator:** ${user.discriminator}\n**ID:** ${user.id}\n**Username:** ${user.username}`
      },
    ],
    timestamp: new Date(),
    footer: {
      icon_url: client.user.avatarURL,
      text: "© Logan 2018"
    }
  }
});
    break;

    case "avatar":
    console.log(`${message.author.tag} used the ${settings.botPREFIX}avatar command!`);
    
    if(message.mentions.users.first()) { //Check if the message has a mention in it.
        let user = message.mentions.users.first(); //Since message.mentions.users returns a collection; we must use the first() method to get the first in the collection.
        let output = user.username + "#" + user.discriminator /*Username and Discriminator*/ +
        "\nAvatar URL: " + user.avatarURL; /*The Avatar URL*/
        message.channel.sendMessage(output); //We send the output in the current channel.
  } else {
        message.reply("Please mention someone :thinking:"); //Reply with a mention saying "Invalid user."
  }
    break;
    case "translate":
    console.log(`${message.author.tag} used the ${settings.botPREFIX}translate command!`);

    const translate = require('google-translate-api');

let toTrans = message.content.split(' ').slice(1);
let language;

language = toTrans[toTrans.length - 2] === 'to' ? toTrans.slice(toTrans.length - 2, toTrans.length)[1].trim() : undefined;
if (!language) {
    return message.reply(`Please supply valid agruments.\n**Example** \`${settings.botPREFIX}translate [text] to [language]\``);
}
let finalToTrans = toTrans.slice(toTrans.length - toTrans.length, toTrans.length - 2).join(' ');
translate(finalToTrans, {to: language}).then(res => {
        message.channel.send({embed: {
            color: 3447003,
            author: {
              name: 'Logan\'s translator',
              icon_url: client.user.avatarURL
            },
            fields: [{
                name: "Translator",
                value: `**From:** ${res.from.language.iso}\n\`\`\`${finalToTrans}\`\`\`\n**To: **${language}\n\`\`\`${res.text}\`\`\``
              }
            ],
            timestamp: new Date(),
            footer: {
              icon_url: client.user.avatarURL,
              text: "© Logan 2018"
            }
          }
        });
}).catch(err => {
    message.channel.send({
        embed: {
            description: '❌ We could not find the supplied language.',
            color: 0xE8642B
        }
    });
});
break;
    case "uptime":
    console.log(`${message.author.tag} used the ${settings.botPREFIX}uptime command!`);

    let ms = client.uptime;
    let cd = 24 * 60 * 60 * 1000; // Calc days
    let ch = 60 * 60 * 1000; // Calc hours
    let cm = 60 * 1000; // Calc minutes
    let cs = 1000; // Calc seconds
    let days = Math.floor(ms / cd);
    let dms = days * cd; // Days, in ms
    let hours = Math.floor((ms - dms) / ch);
    let hms = hours * ch; // Hours, in ms
    let minutes = Math.floor((ms - dms - hms) / cm);
    let mms = minutes * cm; // Minutes, in ms
    let seconds = Math.round((ms - dms - hms - mms) / cs);
    if (seconds === 60) {
        minutes++; // Increase by 1
        seconds = 0;
    }
    if (minutes === 60) {
        hours++; // Inc by 1
        minutes = 0;
    }
    if (hours === 24) {
        days++; // Increase by 1
        hours = 0;
    }
    let dateStrings = [];

    if (days === 1) {
        dateStrings.push('**1** day');
    } else if (days > 1) {
        dateStrings.push('**' + String(days) + '** days');
    }

    if (hours === 1) {
        dateStrings.push('**1** hour');
    } else if (hours > 1) {
        dateStrings.push('**' + String(hours) + '** hours');
    }

    if (minutes === 1) {
        dateStrings.push('**1** minute');
    } else if (minutes > 1) {
        dateStrings.push('**' + String(minutes) + '** minutes');
    }

    if (seconds === 1) {
        dateStrings.push('**1** second');
    } else if (seconds > 1) {
        dateStrings.push('**' + String(seconds) + '** seconds');
    }

    let dateString = '';
    for (let i = 0; i < dateStrings.length - 1; i++) {
        dateString += dateStrings[i];
        dateString += ', ';
    }
    if (dateStrings.length >= 2) {
        dateString = dateString.slice(0, dateString.length - 2) + dateString.slice(dateString.length - 1);
        dateString += 'and ';
    }
    dateString += dateStrings[dateStrings.length - 1];

  message.channel.send({embed: {
    color: 3447003,
    fields: [{
        name: ':clock: Uptime',
        value: 'Bot\'s uptime'
      },
      {
        name: ":runner: Working in:",
        value: `**${client.guilds.size}** servers`
      },
      {
        name: ":white_check_mark: Online for:",
        value: dateString
      }
    ],
    timestamp: new Date(),
    footer: {
      icon_url: client.user.avatarURL,
      text: "© Logan 2018"
    }
  }
});
    break;

  case "modhelp":
  console.log(`${message.author.tag} used the ${settings.botPREFIX}modhelp command!`);

  message.reply("Please check your direct messages :inbox_tray: (Moderation commands.)");

  message.author.send({embed: {
      color: 3447003,
      author: {
        name: client.user.username,
        icon_url: client.user.avatarURL
      },
      title: "Bot's commands",
      fields: [{
          name: "Moderation commands",
          value: `**${settings.botPREFIX}ban** - Bans a user from your server! (Moderators only!)\n\
**${settings.botPREFIX}kick** - Kicks a user out of the server! (Mederation only!)\n\
**${settings.botPREFIX}mute** - Muted a user with a **muted** role! (Moderation only!)\n\
**${settings.botPREFIX}unmute** - Unmutes a user and removes the **muted** role. (Moderation only!)\n\
**${settings.botPREFIX}purge** - Deletes Messages
**${settings.botPREFIX}softban** - Kicks a user and deletes his messages. (Moderation only!)`
        }
      ],
      timestamp: new Date(),
      footer: {
        icon_url: client.user.avatarURL,
        text: "© Logan 2018"
      }
    }
  });
  break;
  case "serverinfo":
  console.log(`${message.author.tag} used the ${settings.botPREFIX}serverinfo command!`);

  let guildmessageServerInfo = message.guild;
  let nameServerInfo = message.guild.name;
  let createdAtServerInfo = moment(message.guild.createdAt).format('MMMM Do YYYY, h:mm:ss a');
  let channelsServerInfo = message.guild.channels.size;
  let ownerServerInfo = message.guild.owner.user.tag;
  let memberCountServerInfo = message.guild.memberCount;
  let largeServerInfo = message.guild.large;
  let iconUrlServerInfo = message.guild.iconURL;
  let regionServerInfo = message.guild.region;
  let afkServerInfo = message.guild.channels.get(message.guild.afkChannelID) === undefined ? 'None' : message.guild.channels.get(guildmessageServerInfo.afkChannelID).name;

      message.channel.send({embed: {
          color: 3447003,
          author: {
            name: message.guild.name,
            icon_url: message.guild.displayAvatarURL
          },
          title: "Server Information",
          fields: [{
              name: "Channels",
              value: `**Channel Count:** ${channelsServerInfo}\n**AFK Channel:** ${afkServerInfo}`
            },
            {
              name: "Members",
              value: `**Member Count:** ${memberCountServerInfo}\n**Owner:** ${ownerServerInfo}\n**Owner ID:** ${message.guild.owner.id}`
            },
            {
              name: "More",
              value: `**Created at:** ${createdAtServerInfo}\n**Large Guild?:** ${largeServerInfo ? 'Yes' : 'No'}\n**Region:** ${regionServerInfo}`
            }
          ],
          timestamp: new Date(),
          footer: {
            icon_url: client.user.avatarURL,
            text: "© Logan 2018"
          }
        }
      });

  break;

  case "botservers":
  console.log(`${message.author.tag} used the ${settings.botPREFIX}botservers command!`);

  let Table = require(`cli-table`);
  let table = new Table({
      head: [
          `ID`,
          `Name`,
          `Users`,
          `Bots`,
          `Total`
      ], colWidths: [30, 50, 10, 10, 10]
  });
  client.guilds.map(g =>
    table.push(
      [g.id, g.name, g.members.filter(u => !u.user.bot).size, g.members.filter(u => u.user.bot).size, g.members.size]
    ));
  require(`snekfetch`)
  .post(`https://hastebin.com/documents`)
  .set(`Content-Type`, `application/raw`)
  .send(table.toString())
  .then(r =>
     message.channel.send(`Im inside these servers! http://hastebin.com/` + r.body.key));
  break;

  case "botping":
  console.log(`${message.author.tag} used the ${settings.botPREFIX}botping command!`);

  message.channel.send({embed: {
      color: 3447003,
      author: {
        name: client.user.username,
        icon_url: client.user.avatarURL
      },
      fields: [{
          name: "Bot's ping:",
          value: `\`${client.ping}ms\``
        }
      ],
      timestamp: new Date(),
      footer: {
        icon_url: client.user.avatarURL,
        text: "© Logan 2018"
      }
    }
  });
  break;
  case "softban":
  console.log(`${message.author.tag} used the ${settings.botPREFIX}softban command!`);

  let reasonSoftban = message.content.split(' ').slice(3).join(' ');
  let timeSoftban = message.content.split(' ')[2];
  let guildSoftban = message.guild;
  let modlogSoftban = message.guild.channels.find('name', 'mod-log');
  let userSoftban = message.mentions.users.first();
  if (!message.guild.member(message.author).hasPermission('BAN_MEMBERS')) {
      return message.reply(':lock: You need to have `BAN_MEMBERS` Permission to execute `SoftBan`');
  }
  if (!message.guild.member(client.user).hasPermission('BAN_MEMBERS')) {
      return message.reply(':lock: I need to have `BAN_MEMBERS` Permission to execute `SoftBan`');
  }
  if (!modlogSoftban) {
      return message.reply('I need a text channel named `mod-log` to print my ban/kick logs in, please create one');
  }
  if (message.author.id === userSoftban.id) {
      return message.reply('You cant punish yourself :wink:');
  }
  if (message.mentions.users.size < 1) {
      return message.reply('You need to mention someone to SoftBan him!');
  }
  if (!reasonSoftban) {
      return message.reply(`You must give me a reason for the ban **Usage:**\`l.softban [@mention] [example]\``);
  }
  userSoftban.send(`You've just got softbanned from ${guildSoftban.name}  \n State reason: **${reasonSoftban}** \n **Disclamer**: In a softban you can come back straight away, we just got your messages deleted`);
  message.guild.ban(userSoftban, 2);
  setTimeout(() => {
      message.guild.unban(userSoftban.id);
  }, 0);

  modlogSoftban.send({embed: {
      color: 0x18FE26,
      author: {
        name: client.user.username,
        icon_url: client.user.avatarURL
      },
      fields: [{
          name: "Softban:",
          value: `**Softbanned:** ${userSoftban.username}#${userSoftban.discriminator}\n**Moderator:** ${message.author.username}\n**Reason:** ${reasonSoftban}`
        }
      ],
      timestamp: new Date(),
      footer: {
        icon_url: client.user.avatarURL,
        text: "© Logan 2018"
      }
    }
  });
  break;
  case "botname":
  console.log(`${message.author.tag} used the ${settings.botPREFIX}botname command!`);

  const botusername = message.content.split(' ').slice(1).join(' ');

  if (message.author.id == '338192747754160138') {
      client.user.setUsername(botusername);
      message.reply('Done. :ok_hand:');
  } else {
      message.delete();
      message.channel.send(`\`📛\` You don't have permissions to execute that command.`);
  }
  break;

  case "botavatar":
  console.log(`${message.author.tag} used the ${settings.botPREFIX}botavatar command!`);

  const botavatar = message.content.split(' ').slice(1).join(' ');
  var request = require("request").defaults({ "encoding" : null });

  if (message.author.id == '338192747754160138') {
request(botavatar, function (err, res, body) {
if (!err && res.statusCode === 200) {
  var data = "data:" + res.headers["content-type"] + ";base64," + new Buffer(body).toString("base64");
  client.user.setAvatar(botavatar).catch((error) => { message.channel.send('Beep boop, something went wrong. Check the console to see the error.'); console.log('Error on setavatar command:', error); });

  message.channel.send('Done. :ok_hand:');
}
});
  } else {
      message.delete();
      message.channel.send(`\`📛\` You don't have permissions to execute that command.`);
  }
  break;

  case "botnick":
  console.log(`${message.author.tag} used the ${settings.botPREFIX}botnick command!`);

  const botnickname = message.content.split(' ').slice(1).join(' ');

  if (message.author.id == '338192747754160138'){
      message.guild.members.get(client.user.id).setNickname(botnickname);
      message.channel.send('Done. :ok_hand:');
  } else {
      message.delete();
      message.channel.send(`\`📛\` You don't have permissions to execute that command.`);
  }
  break;

  case "eval":
  console.log(`${message.author.tag} used the ${settings.botPREFIX}eval command!`);

  const clean = text => {
    if (typeof(text) === "string")
      return text.replace(/`/g, "`" + String.fromCharCode(8203)).replace(/@/g, "@" + String.fromCharCode(8203));
    else
        return text;
  }

    const evalargs = message.content.split(" ").slice(1);

      if (message.author.id == settings.ownerID || message.author.id == '153478211207036929') {
        try {
            const code = args.join(" ");
            let evaled = eval(code);
            let rawEvaled = evaled;
            if (typeof evaled !== "string")
                evaled = require("util").inspect(evaled, { showHidden: false, depth: 3 });
            let cleaned = clean(evaled);
            if (args[0] != undefined && args[0] != '') {
                try {
                    let embed = new Discord.RichEmbed()
                        .setColor('#AABBED')
                        .setTitle('Evaluation')
                        .addField('Evaluated', '```js\n' + code + '```')
                        .addField('Result', '```xl\n' + cleaned + '```')
                        .addField('Type', '```js\n' + (typeof rawEvaled).substr(0, 1).toUpperCase() + (typeof rawEvaled).substr(1) + '```');
                    return message.channel.send(embed);
                } catch (err) {
                    require('hastebin-generator')(cleaned, 'js').then(link => {
                        let embed = new Discord.RichEmbed()
                            .setColor('#AABBED')
                            .setTitle('Evaluation')
                            .addField('Evaluated', '```js\n' + args.join(" ") + '```')
                            .addField('Result', '[```xl\n' + 'CLICK' + '```](' + link + ')')
                            .addField('Type', '```js\n' + (typeof rawEvaled).substr(0, 1).toUpperCase() + (typeof rawEvaled).substr(1) + '```')
                        return message.channel.send(embed);
                    });
                }
            } else {
                try {
                    let embed = new Discord.RichEmbed()
                        .setColor('#AABBED')
                        .setTitle('Evaluation')
                        .addField('Evaluated', '```js\nundefined```')
                        .addField('Result', '```xl\n' + cleaned + '```')
                        .addField('Type', '```js\n' + (typeof rawEvaled).substr(0, 1).toUpperCase() + (typeof rawEvaled).substr(1) + '```');
                    return message.channel.send(embed);
                } catch (err) {
                    require('hastebin-generator')(cleaned, 'js').then(link => {
                        let embed = new Discord.RichEmbed()
                            .setColor('#AABBED')
                            .setTitle('Evaluation')
                            .addField('Evaluated', '```js\nundefined```')
                            .addField('Result', '[```xl\n' + 'CLICK' + '```](' + link + ')')
                            .addField('Type', '```js\n' + (typeof rawEvaled).substr(0, 1).toUpperCase() + (typeof rawEvaled).substr(1) + '```')
                        return message.channel.send(embed);
                    });
                }
            }
        } catch (err) {
            let embed = new Discord.RichEmbed()
                .setColor('#770306')
                .setTitle('Error')
                .addField('Evaluated', '```js\n' + args.join(" ") + '```')
                .addField('Result', '```xl\n' + err.toString() + '```')
                .addField('Type', '```js\nError```')
            return message.channel.send(embed).catch(err => {
                require('hastebin-generator')(err, 'js').then(link => {
                    let embed = new Discord.RichEmbed()
                        .setColor('#770306')
                        .setTitle('Evaluation')
                        .addField('Evaluated', '```js\n' + args.join(" ") + '```')
                        .addField('Result', '[```xl\n' + 'CLICK' + '```](' + link + ')')
                        .addField('Type', '```js\nError```');
                    return message.channel.send(embed);
                });
            });
        }
        return;
    } else {
        message.reply('You don\'t own me!');
    }


          
  break;

  case "say":
  console.log(`${message.author.tag} used the ${settings.botPREFIX}say command!`);

  const botsay = message.content.split(' ').slice(1).join(' ');

  if (message.author.id == '338192747754160138' || message.author.id == '338192747754160138')
  {
      message.delete();
      message.channel.send(botsay);
  } else {
      message.delete();
      message.channel.send(`\`📛\` You don't have permissions to execute that command.`);
  }
  break;

  case "shutdown":
  console.log(`${message.author.tag} used the ${settings.botPREFIX}shutdown command!`);

  if (message.author.id == '338192747754160138' || message.author.id == '338192747754160138') { //399648813872185346
          const filterYes = m => m.content.startsWith('yes');
          message.reply('Shutting down... :skull:')
          .then(m => {
              process.exit()
          });
  } else {
      message.delete();
      message.channel.send(`\`📛\` You don't have permissions to execute that command.`);
  }
  break;

  case "ownerhelp":
  console.log(`${message.author.tag} used the ${settings.botPREFIX}ownerhelp command!`);

  if (message.author.id == '338192747754160138') {
      message.reply("Please check your direct messages :inbox_tray: (Owner commands.)");

      message.author.send({embed: {
          color: 3447003,
          author: {
            name: client.user.username,
            icon_url: client.user.avatarURL
          },
          title: "Bot's commands",
          fields: [{
              name: "Bot's owner commands",
              value: `**${settings.botPREFIX}botname** - Changes the bot's username. **Usage: ${settings.botPREFIX}botname [NAME]**\n\
**${settings.botPREFIX}botavatar** - Changes the bot's avatar. **Usage: ${settings.botPREFIX}botavatar [LINK]**\n\
**${settings.botPREFIX}botnick** - Changed the nickname in a server. **Usage: ${settings.botPREFIX}botnick [NICKNAME]**\n\
**${settings.botPREFIX}eval** - Evaluates a code. **Usage: ${settings.botPREFIX}eval [CODE]**\n\
**${settings.botPREFIX}shutdown** - Closes the CMD window!\n\
**${settings.botPREFIX}say** - Give the bot something to say!`
            }
          ],
          timestamp: new Date(),
          footer: {
            icon_url: client.user.avatarURL,
            text: "© Logan 2018"
          }
        }
      });
  } else {
      message.delete();
      message.channel.send(`\`📛\` Only the owner of the bot can use this command.`);
  }
  break;
  case "mute":
  console.log(`${message.author.tag} used the ${settings.botPREFIX}mute command!`);

  if (!message.guild.member(message.author).hasPermission('MUTE_MEMBERS')) {
      message.channel.send(':lock: **I** need `MANAGE_ROLES` Permissions to execute `mute`');
      return;
  }

  if (!message.guild.member(client.user).hasPermission('MANAGE_ROLES')) {
      return message.reply(':lock: **I** need `MANAGE_ROLES` Permissions to execute `mute`')
  }
  const msmute = require('ms');
  let reasonMute = message.content.split(' ').slice(3).join(' ');
  let timeMute = message.content.split(' ')[2];
  let guildMute = message.guild;
// Let adminRoleMute = guild.roles.find("name", "TOA");
  let memberMute = message.guild.member;
  let modlogMute = message.guild.channels.find('name', 'mod-log');
  let userMute = message.mentions.users.first();
  let muteRoleMute = client.guilds.get(message.guild.id).roles.find('name', 'Muted');
  if (!modlogMute) {
      return message.reply('I need a text channel named `mod-log` to print my ban/kick logs in, please create one');
  }

  if (!muteRoleMute) {
      return message.reply('`Please create a role called "Muted"`');
  }

  if (message.mentions.users.size < 1) {
      return message.reply('You need to mention someone to Mute .');
  }
  if (message.author.id === userMute.id) {
      return message.reply('You cant punish yourself :wink:');
  }
  if (!timeMute) {
      return message.reply('specify the time for the mute!**Usage:**`l.mute [@mention] [1m] [example]`');
  }
  if (!timeMute.match(/[1-60][s,m,h,d,w]/g)) {
      return message.reply('I need a valid time ! look at the Usage! right here: **Usage:**`l.mute [@mention] [1m] [example]`');
  }
  if (!reasonMute) {
      return message.reply('You must give me a reason for Mute **Usage:**`l.mute [@mention] [15m] [example]`');
  }
  if (reasonMute.time < 1) {
      return message.reply('TIME?').then(message => message.delete(2000));
  }
  if (reasonMute.length < 1) {
      return message.reply('You must give me a reason for Mute');
  }
  message.guild.member(userMute).addRole(muteRoleMute)

  setTimeout(() => {
      message.guild.member(userMute).removeRole(muteRoleMute)
  }, msmute(timeMute));
  message.guild.channels.filter(textchannel => textchannel.type === 'text').forEach(cnl => {
      cnl.overwritePermissions(muteRoleMute, {
          SEND_MESSAGES: false
      });
  });

  message.reply("This user has been muted.");

  modlogMute.send({embed: {
      color: 16745560,
      author: {
        name: client.user.username,
        icon_url: client.user.avatarURL
      },
      fields: [{
          name: 'Mute',
          value: `**Muted:**${userMute.username}#${userMute.discriminator}\n**Moderator:** ${message.author.username}\n**Duration:** ${msmute(msmute(timeMute), {long: true})}\n**Reason:** ${reasonMute}`
        }
      ],
      timestamp: new Date(),
      footer: {
        icon_url: client.user.avatarURL,
        text: "© Logan 2018"
      }
    }
  });
  break;

  case "unmute":
  console.log(`${message.author.tag} used the ${settings.botPREFIX}unmute command!`);

  let guildUnmute = message.guild;
  let argsUnmute = message.content.split(' ').slice(1);
  let argresultUnmute = args.join(' ');
  let reasonUnmute = args;
  if (!message.guild.member(message.author).hasPermission('MANAGE_ROLES')) {
      return message.reply(':lock: **I** need `MANAGE_ROLES` Permissions to execute `mute`')
  }
  if (!message.guild.member(client.user).hasPermission('MANAGE_ROLES')) {
      return message.reply(':lock: **I** need `MANAGE_ROLES` Permissions to execute `mute`')
  }
  let userUnmute = message.mentions.users.first();
  let muteRoleUnmute = client.guilds.get(message.guild.id).roles.find('name', 'muted');
  if (message.mentions.users.size < 1) {
      return message.reply('You need to mention someone to unmute him!.');
  }
  message.guild.member(userUnmute).removeRole(muteRoleUnmute).then(() => {
      message.reply(`You've succesfully unmuted ${userUnmute}`);
  });
  break;

  case "bluehelp":
  console.log(`${message.author.tag} used the ${settings.botPREFIX}bluehelp command!`);

  if (message.author.id == '338192747754160138') {
      message.reply('Hello there my lord! Check your DM :wink:');

      message.author.send({embed: {
          color: 3447003,
          author: {
            name: client.user.username,
            icon_url: client.user.avatarURL
          },
          title: "Bot's commands",
          fields: [{
              name: "City Guards dev commands",
              value: `**${settings.botPREFIX}todo** - Shows Blue Malgeran's TODO list.\n\
**${settings.botPREFIX}eval** - Evaluates a code.\n\
**${settings.botPREFIX}shutdown** - Closes the CMD window.\n\
**${settings.botPREFIX}say** - Give the bot something to say!`
            }
          ],
          timestamp: new Date(),
          footer: {
            icon_url: client.user.avatarURL,
            text: "© Logan 2018"
          }
        }
      });
  } else {
      message.delete();
      message.channel.send(`\`📛\` You're not allowed to execute this command, only my lord can use this command!\n\
      \`Lord: Tea Cup#3343\``);
  }
  }
});
    


  

    
    client.on('message', function (message) {
        if (message.content.startsWith('l.8ball')) {
            const replies = ["It is certain",
            "It is decidedly so",
                "Without a doubt",
            "Yes, definitely",
                "You may rely on it",
            "As I see it, yes",
                "Most likely",
            "Outlook good",
                "Yes",
            "Signs point to yes",
                "Reply hazy try again",
            "Ask again later",
                "Better not tell you now",
            "Cannot predict now",
                "Concentrate and ask again",
            "Don't count on it",
                "My reply is no",
            "My sources say no",
                "Outlook not so good",
            "Very doubtful"];
                message.replytext = Math.floor((Math.random() * replies.length) + 0);
            return message.reply(replies[message.replytext]);
          }
          if (message.content.startsWith(prefix + 'HOOK')) { // We are using a .startsWith because the command will have arguments.

            // Delete the message that the user sends
            message.delete();
        
            if (message === prefix + 'HOOK') { // This checks if the only thing they sent was 'Hook'
                return hook(message.channel, 'Hook Usage', `${prefix}hook <title>, <message>, [HEXcolor], [avatarURL]\n\n**<> is required\n[] is optional**`,'FC8469','https://cdn4.iconfinder.com/data/icons/global-logistics-3/512/129-512.png') // Remeber that \n means new line. This is also using a custom HEX id, and an image.
            }
        
            let hookArgs = message.content.slice(prefix.length + 4).split(","); // This slices the first 6 letters (prefix & the word hook) then splits them by 'commas'
        
            hook(message.channel, hookArgs[0], hookArgs[1], hookArgs[2], hookArgs[3]); // This is where it actually calls the hook.
        }

    });
    
          

//Servers > ${bot.guilds.size} :greenTick: \n Users > ${bot.users.size} :greenTick:\n Uptiime > :soon~1: 
    client.on("guildMemberAdd", (member) => {
        console.log(`New User "${member.user.username}" has joined "${member.guild.name}"` );
        });
//-----------------MUSIC---------------------------MUSIC---------------------MUSIC-----------------------------------------MUSIC-----


const { Client, Util } = require('discord.js');
const { TOKEN, PREFIX, GOOGLE_API_KEY } = require('./config');
const YouTube = require('simple-youtube-api');
const ytdl = require('ytdl-core');


const client = new Client({ disableEveryone: true });

const youtube = new YouTube(GOOGLE_API_KEY);

const queue = new Map();

client.on('warn', console.warn);

client.on('error', console.error);

client.on('ready', () => console.log('Yo this ready!'));

client.on('disconnect', () => console.log('I just disconnected, making sure you know, I will reconnect now...'));

client.on('reconnecting', () => console.log('I am reconnecting now!'));

client.on('message', async msg => { // eslint-disable-line
	if (msg.author.bot) return undefined;
	if (!msg.content.startsWith(PREFIX)) return undefined;

	const args = msg.content.split(' ');
	const searchString = args.slice(1).join(' ');
	const url = args[1] ? args[1].replace(/<(.+)>/g, '$1') : '';
	const serverQueue = queue.get(msg.guild.id);

	let command = msg.content.toLowerCase().split(' ')[0];
	command = command.slice(PREFIX.length)

	if (command === 'play') {
		const voiceChannel = msg.member.voiceChannel;
		if (!voiceChannel) return msg.channel.send('I\'m sorry but you need to be in a voice channel to play music!');
		const permissions = voiceChannel.permissionsFor(msg.client.user);
		if (!permissions.has('CONNECT')) {
			return msg.channel.send('I cannot connect to your voice channel, make sure I have the proper permissions!');
		}
		if (!permissions.has('SPEAK')) {
			return msg.channel.send('I cannot speak in this voice channel, make sure I have the proper permissions!');
		}

		if (url.match(/^https?:\/\/(www.youtube.com|youtube.com)\/playlist(.*)$/)) {
			const playlist = await youtube.getPlaylist(url);
			const videos = await playlist.getVideos();
			for (const video of Object.values(videos)) {
				const video2 = await youtube.getVideoByID(video.id); // eslint-disable-line no-await-in-loop
				await handleVideo(video2, msg, voiceChannel, true); // eslint-disable-line no-await-in-loop
			}
			return msg.channel.send(`✅ Playlist: **${playlist.title}** has been added to the queue!`);
		} else {
			try {
				var video = await youtube.getVideo(url);
			} catch (error) {
				try {
					var videos = await youtube.searchVideos(searchString, 10);
					let index = 0;
					msg.channel.send(`
__**Song selection:**__
${videos.map(video2 => `**${++index} -** ${video2.title}`).join('\n')}
Please provide a value to select one of the search results ranging from 1-10.
					`);
					// eslint-disable-next-line max-depth
					try {
						var response = await msg.channel.awaitMessages(msg2 => msg2.content > 0 && msg2.content < 11, {
							maxMatches: 1,
							time: 10000,
							errors: ['time']
						});
					} catch (err) {
						console.error(err);
						return msg.channel.send('No or invalid value entered, cancelling video selection.');
					}
					const videoIndex = parseInt(response.first().content);
					var video = await youtube.getVideoByID(videos[videoIndex - 1].id);
				} catch (err) {
					console.error(err);
					return msg.channel.send('🆘 I could not obtain any search results.');
				}
			}
			return handleVideo(video, msg, voiceChannel);
		}
	} else if (command === 'skip') {
		if (!msg.member.voiceChannel) return msg.channel.send('You are not in a voice channel!');
		if (!serverQueue) return msg.channel.send('There is nothing playing that I could skip for you.');
		serverQueue.connection.dispatcher.end('Skip command has been used!');
		return undefined;
	} else if (command === 'stop') {
		if (!msg.member.voiceChannel) return msg.channel.send('You are not in a voice channel!');
		if (!serverQueue) return msg.channel.send('There is nothing playing that I could stop for you.');
		serverQueue.songs = [];
		serverQueue.connection.dispatcher.end('Stop command has been used!');
		return undefined;
	} else if (command === 'volume') {
		if (!msg.member.voiceChannel) return msg.channel.send('You are not in a voice channel!');
		if (!serverQueue) return msg.channel.send('There is nothing playing.');
		if (!args[1]) return msg.channel.send(`The current volume is: **${serverQueue.volume}**`);
		serverQueue.volume = args[1];
		serverQueue.connection.dispatcher.setVolumeLogarithmic(args[1] / 5);
		return msg.channel.send(`I set the volume to: **${args[1]}**`);
	} else if (command === 'np') {
		if (!serverQueue) return msg.channel.send('There is nothing playing.');
		return msg.channel.send(`🎶 Now playing: **${serverQueue.songs[0].title}**`);
	} else if (command === 'queue') {
		if (!serverQueue) return msg.channel.send('There is nothing playing.');
		return msg.channel.send(`
__**Song queue:**__
${serverQueue.songs.map(song => `**-** ${song.title}`).join('\n')}
**Now playing:** ${serverQueue.songs[0].title}
		`);
	} else if (command === 'pause') {
		if (serverQueue && serverQueue.playing) {
			serverQueue.playing = false;
			serverQueue.connection.dispatcher.pause();
			return msg.channel.send('⏸ Paused the music for you!');
		}
		return msg.channel.send('There is nothing playing.');
	} else if (command === 'resume') {
		if (serverQueue && !serverQueue.playing) {
			serverQueue.playing = true;
			serverQueue.connection.dispatcher.resume();
			return msg.channel.send('▶ Resumed the music for you!');
		}
		return msg.channel.send('There is nothing playing.');
	}

	return undefined;
});

async function handleVideo(video, msg, voiceChannel, playlist = false) {
	const serverQueue = queue.get(msg.guild.id);
	console.log(video);
	const song = {
		id: video.id,
		title: Util.escapeMarkdown(video.title),
		url: `https://www.youtube.com/watch?v=${video.id}`
	};
	if (!serverQueue) {
		const queueConstruct = {
			textChannel: msg.channel,
			voiceChannel: voiceChannel,
			connection: null,
			songs: [],
			volume: 5,
			playing: true
		};
		queue.set(msg.guild.id, queueConstruct);

		queueConstruct.songs.push(song);

		try {
			var connection = await voiceChannel.join();
			queueConstruct.connection = connection;
			play(msg.guild, queueConstruct.songs[0]);
		} catch (error) {
			console.error(`I could not join the voice channel: ${error}`);
			queue.delete(msg.guild.id);
			return msg.channel.send(`I could not join the voice channel: ${error}`);
		}
	} else {
		serverQueue.songs.push(song);
		console.log(serverQueue.songs);
		if (playlist) return undefined;
		else return msg.channel.send(`✅ **${song.title}** has been added to the queue!`);
	}
	return undefined;
}

function play(guild, song) {
	const serverQueue = queue.get(guild.id);

	if (!song) {
		serverQueue.voiceChannel.leave();
		queue.delete(guild.id);
		return;
	}
	console.log(serverQueue.songs);

	const dispatcher = serverQueue.connection.playStream(ytdl(song.url))
		.on('end', reason => {
			if (reason === 'Stream is not generating quickly enough.') console.log('Song ended.');
			else console.log(reason);
			serverQueue.songs.shift();
			play(guild, serverQueue.songs[0]);
		})
		.on('error', error => console.error(error));
	dispatcher.setVolumeLogarithmic(serverQueue.volume / 5);

	serverQueue.textChannel.send(`🎶 Start playing: **${song.title}**`);
}

client.login(TOKEN);



